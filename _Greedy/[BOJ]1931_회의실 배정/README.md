# [BOJ]/[1931] 회의실 배정

## *- greedy -*

* 각 회의의 **끝나는 시간을 기준으로 오름차순으로 정렬**한다.

* 가장 먼저 끝나는 회의를 시작으로 각 회의의 시간을 확인한다.

  * 이때까지 한 회의의 끝나는 시간 `endTime`보다 현재 회의의 시작시간이 크거나 같으면 해당 회의를 추가한다. (`cnt++`) 그리고 `endTime`을 현재 회의의 끝나는 시간으로 갱신한다.

    이를 모든 회의 시간을 확인할 동안 반복한다.

    `cnt`값이 최대로 할 수 있는 회의 개수.

* **:star2: 이때, 각 회의의 끝나는 시간으로 오름차순을 정렬할 때, 만약 끝나는 시간이 같다면 시작하는 시간을 오름차순으로 정렬해주어야 한다.**

  * 예를 들어, (5, 5), (3, 5), (2, 5) 라는 회의가 있을 때 이 세 회의는 끝나는 시간이 같다.
  * 만약 끝나는 시간만을 고려하여 정렬했을 때는 위 순서 그대로가 될 수 있는데, 이 경우 최대 회의 개수는 **1개**가 된다. 
    * (5, 5) 회의를 하고 나면 `endTime=5`가 되고, 그렇게 되면 뒤의 두 회의는 시작할 수 없게 되기 때문이다. 
  * 따라서, 끝나는 시간이 같다면 시작하는 시간으로 오름차순으로 정렬해주어야한다.
    * 이에 따라 정렬하게 되면 (2, 5), (3, 5), (5, 5) 가 되고 첫 번째 회의 (2, 5)가 끝나면 `endTime=5`. 그러면 (5, 5)회의는 시작할 수 있으므로 최대 회의 개수는 **2개**가 된다. 

>**:star: JAVA**
>
>* **Comparable** vs **Comparator** 
>
>1. ***Comparable***
>
>   * **정의**: 정렬 수행 시 <u>기본적으로 적용</u>되는 정렬 기준이 되는 메서드를 정의하는 인터페이스
>
>     * Java에서 제공되는 정렬이 가능한 클래스는 모두 `Comparable`인터페이스를 구현하고 있으며, 정렬 시에 이에 맞게 정렬이 수행된다.
>     * 그래서 PriorityQueue의 타입으로 사용자 정의된 클래스 객체를 구현할 때 `Comparable`을 구현해주는 것!!
>
>   * **구현 방법**: 정렬할 객체에 `Comparable` 인터페이스를 implements 후, `compareTo()`메서드를 오버라이드하여 구현한다.
>
>     * `compareTo()` 메서드 작성법
>
>       1. 현재 객체 **<** 파라미터로 넘어온 객체 : 음수 return
>       2. 현재 객체 **==** 파라미터로 넘어온 객체 : 0 return
>       3. 현재 객체 **>** 파라미터로 넘어온 객체 : 양수 return
>
>       => 음수나 0이면 객체의 자리가 그대로 유지되며, 양수인 경우에는 두 객체의 자리가 바뀐다.
>
>2. ***Comparator***
>
>   * **정의**: 정렬 가능한 클래스들의 <u>기본 정렬 기준과 다르게 정렬</u>하고 싶을 때 사용하는 인터페이스
>
>     * 기본적인 정렬방법인 오름차순 정렬을 내림차순으로 정렬할 때 많이 사용한다.
>
>   * **구현 방법**: `Comparator` 인텊페이스를 implements 후, `compare()` 메서드를 오버라이트한 myComparator 클래스를 작성한다.
>
>     * `compare()`메서드 작성법
>
>       * 첫 번째 파라미터 객체 **<** 두 번째 파라미터 객체 : 음수 return
>       * 첫 번째 파라미터 객체 **==** 두 번째 파라미터 객체 : 0 return
>       * 첫 번째 파라미터 객체  **>** 두 번째 파라미터 객체 : 양수 return
>
>       => 음수 또는 0이면 객체의 자리가 그대로 유지되며, 양수인 경우에는 두 객체의 자리가 변경된다.
>
>   * 예시
>
>     ```java
>     // 해당 문제에서 각 회의시간을 정렬할 때 사용
>     int[][] time = new int[N][2];
>     Arrays.sort(time, new Comparator<int[]>(){
>         @Override
>         public int compare(int[] a, int[] b){
>             if(a[1] == b[1]) // 끝나는 시간이 같으면
>                 return a[0] - b[0]; // 시작 시간으로 오름차순 정렬
>             else // 그렇지 않으면
>                 return a[1] - b[1]; // 끝나는 시간으로 오름차순 정렬
>         }
>     })
>     ```

