# [BOJ]/[1753] 최단경로

## - Dijkstra -

> **:star:Dijkstra** 
>
> : 최단경로 탐색 알고리즘
>
> * 특정 하나의 정점에서 다른 모든 정점으로 가는 최단경로를 구한다.
>
> * 음의 간선은 포함할 수 없다. (하지만 현실 세계에서 음의 간선은 존재하지 않으므로 다익스트라는 현실 세계에 아주 적합함)
>
> * 다익스트라는 ***DP***이다
>
>   (최단거리는 여러 개의 최단거리로 이루어져있기 때문
>
>   하나의 최단거리를 구할 때, 이전에 구했던 최단거리 정보를 그대로 사용함)
>
> * **< 과정 >**
>
>   1) 출발 노드를 설정
>
>   2) 출발노드 기준 각 노드의 최단거리를 저장
>
>   3) 방문하지 않은 노드 중 가장 거리가 짧은 노드 선택
>
>   4) 해당 노드를 거쳐서 특정노드로 가는 경우를 고려하여 최단거리를 갱신
>
>   5) 3), 4)과정을 반복한다
>
> * 배열을 통해 구현는 방법
>
>   -> 최단거리를 단순히 선형탐색으로 찾아 시간 복잡도가 O(N^2)가 된다.
>
>   ​	정점은 많은데 간선이 적을 때는 비효율적으로 작동하게 된다
>
> * 인접리스트를 통해 구현하는 방법
>
>   -> 힙구조를 이용해 최단거리를 찾아 시간 복잡도가 O(N*logN)이 된다.
>
>   정점에 비해 간선의 갯수가 비정상적으로 적어도 안정적으로 처리가능하다

* `ArrayList<Edge>[] adj = new ArrayList[V+1];`

  : 인접리스트

* `int[] D = new int[V+1];`

  : 출발지(`int start`)로 부터의 최단 거리

  출발지를 제외한 나머지 노드들은 `Integer.MAX_VALUE`로 초기화해둔다.

  출발지는 `0`으로 초기화

* `PriorityQueue<Edge> pq`

  : 최단거리를 위한 우선순위 큐

  ***:star:간선의 가중치가 아닌 시작점으로부터의 거리로 우선순위를 둬야한다***  (짧은 거리가 우선순위가 높은 것)

  출발지 노드만 `add`해 초기화한다 (`pq.add(new Edge(start, 0));`)

* `pq`가 빌 때까지 아래 과정 반복

  * `pq`의 가장 첫번째 노드를 `poll()` -> 이는 출발지에서 가장 가까운 노드(`edge`) !

  * 이 노드와 연결된 노드들을 탐색

    * 방문하지 않은 노드이고, 해당 노드까지의 거리 값보다 (`edge`노드까지의 거리+해당노드의 `weight`) 값이 더 작다면 이 값으로 해당 노드까지의 거리값 `D`를 갱신한다.

      갱신된 노드는 `pq`에 `add()`

    * 연결된 노드를 모두 탐색한 후 이 노드의 방문여부를 `true`로 바꿔준다.

      (연결된 노드를 **모두** 탐색한 **"후"**에 바꿔주어야 함)

> **:star: In Java**
>
> `PriorityQueue`의 요소를 사용자 정의 객체로 해주기 위해 다음과 같이 처리해준다
>
> ```java
> static class Edge implements Comparable<Edge>{ //Comparable클래스를 상속
>     
> 	...
>         
> 	@Override
> 	public int compareTo(Edge o) {
> 		return Integer.compare(this.weight, o.weight);
>         // (+)Integer.compare(a,b) -> a가 크면 1, b가 크면 -1, 같으면 0
> 	}	
> }
> ```

</br>

## :speaking_head:

* 이전 코테에서 dfs로 백트래킹써서 풀었는데 알고보니 다익스트라 문제였다. 다익스트라로 하니까 훨씬 시간이 단축되는 것 같다 .. 이제라도 공부하자!