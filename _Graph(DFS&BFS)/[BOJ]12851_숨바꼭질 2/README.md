# [BOJ]/[12851] 숨바꼭질 2

## *- BFS -*

* `int MinTime = Integer.MAX_VALUE` : 동생을 찾는데에 걸리는 최소 시간
* `int cnt` : 그 경우의 수

</br>

* `int[] Time = new int[100001]` : 해당 위치까지 가는데에 걸리는 최소시간
  * 수빈이의 위치의 값은 `0`으로
  * 나머지는 최대값 `Integer.MAX_VALUE`로 초기화
* `Queue<int[]> q` : 현재 위치, 이까지오는데 걸린 시간을 저장
  * 수빈이의 위치와 걸린 시간 `0`을 추가해준다.

1. `q`가 빌 때까지 아래의 과정을 반복.

   현재 위치를 `x` , 이때까지 걸린 시간을 `time`

2. 현재 위치가 도착지점이라면, 그 때까지 걸린 시간과 `MinTime`을 비교한다.

   * 만약 더 적은 시간이 걸렸다면, 그 값으로 `MinTime`값을 바꾸고 경우의 수도 `1`로 바꿔준다.
   * 만약 같은 시간이 걸렸다면, 경우의 수를 `1` 늘려준다.
   * 아래의 과정 하지않고 `continue`

3. `(x+1)`이 범위내에 속하고 이전에 `Time`값보다 `(time+1)`값이 더 작거나 같다면,

   `(x+1)`과 `(time+1)`을 `q`에 추가해준다.

   또 `(x+1)`이 도착점이 아니고, `(time+1)`이 `Time`값보다 작다면 그 값으로 `Time`값을 바꾼다.

4. `(x-1)`로 3번과정을 진행한다.

5. `(x*2)`로 3번과정을 진행한다.

6. 반복을 종료했을 때의 `MaxTime`과 `cnt`가 결과값.

</br>

## :speaking_head:

처음에 그냥 방문여부로 체크해주었는데, 가능한 경우의 수를 구해야하기 때문에 방문했던 위치도 다시 방문해야할 경우가 생긴다. 그래서 틀렸다.

따라서, 해당 위치까지 가는데에 걸리는 최소 시간을 저장하고, 그 시간보다 작거나 같으면 그 위치에서 또 이동하는 방식으로 진행했더니 통과하였다.