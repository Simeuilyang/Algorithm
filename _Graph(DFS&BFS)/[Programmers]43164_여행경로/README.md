# [Programmers]/[43164] 여행경로

## *- DFS -*

```java
Map<String, ArrayList<Ticket>> adj;
```

* map을 이용해 각 공항에서 출발하는 티켓을 저장한다.
* `class Ticket`: 주어지는 `tickets`배열에서의 인덱스와 도착 공항 이름을 가진다.
  * 도착 공항 이름 오름차순으로 정렬된다.

1. 위의 `adj`맵에 `tickets`의 정보를 저장한다.

   * 모든 티켓을 다 사용해야 하므로 사용여부를 확인해주기 위해 인덱스도 함께 저장한다.

2. 가능한 경로가 2개 이상일 경우, 알파벳 순서가 앞서는 경로를 선택해야하므로 각 티켓을 도착 공항 이름 오름차순대로 정렬한다.

   * 만약 가능한 경로가 나오면,  그 이후는 생각하지 않아도 됨. (알파벳 순서가 앞서는 경로부터 확인했으므로)

3. dfs를 이용해 경로를 찾는다.

   ```java
   boolean dfs(String now, ArrayList<String> res, boolean[] used, Map<String, ArrayList<Ticket>> adj)
   ```

   * `now` : 현재 공항, `res` : 경로를 담을 리스트, `used` : 사용 여부를 체크할 배열

   1. 먼저 현재 공항에서 출발할 수 있는 티켓 리스트를 확인한다.

      만약, 그러한 티켓이 없다면 해당 공항이 마지막이 되어야 함.

      => 이 때 모든 티켓을 사용했는지 확인한다. (`boolean ChkAllUsed(boolean[] used)`)

      * 모든 티켓을 사용했다면, 모든 조건을 만족한 경로이므로 `true`를 리턴.
      * 사용하지 않은 티켓이 있다면, 조건을 아직 만족하지 않은 경로이므로 다른 경로를 찾기 위해 `false`를 리턴한다.

   2. 티켓이 있다면, 그 티켓들을 하나씩 확인한다.

      만약, 사용하지 않은 티켓이라면,

      * 그 티켓의 도착점을 경로에 추가하고, 사용여부를 체크한 후, 해당 도착점으로 `dfs`를 호출한다.

        => 이 리턴값이 `true`라면, 구한 경로가 올바른 경로이므로 똑같이 `true`를 리턴

        => `false`라면, 구한 경로가 잘못된 경로이므로 경로에서 해당 공항을 제외하고, 사용 여부도 다시 `false`로 되돌린 후, 다음 티켓을 확인한다.

   3. 티켓을 모두 확인 후, 현재 모든 티켓을 사용했는지 확인한다.

      * 모두 확인했다면, 현재 공항이 마지막 공항으로 `true`를 리턴.
      * 그렇지 않다면 `false`를 리턴하고 다른 경로를 찾는다.

</br>

## :speaking_head:

처음에는 `Map`에 `<String, PriorityQueue<String>>`을 저장하여서 사용한 티켓은 바로 삭제하여 경로를 찾는 방식으로 처리하였는데, 이 방법으로는 만약 더 이상 갈 수 있는 티켓이 없는데 사용하지 않은 티켓이 남아있을 수 있는 경우가 생긴다. 

=> 그래서, 사용 여부를 체크해주는 방식으로 처리하니까 해결할 수 있었다.