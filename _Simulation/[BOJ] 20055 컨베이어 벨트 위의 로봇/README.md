# [BOJ]/[20055] 컨베이어 벨트 위의 로봇

## - Simulation -

* `int[] Dura` : 벨트 `0` ~ `2N-1`번째 까지의 내구도
* `ArrayList<Integer> box` : 각 박스로봇의 위치
* `int step` : 단계. `0`으로 초기화하고, 1 ~ 4까지의 과정을 끝내면 `+1` 해준다
  					1. 벨트가 한 칸 회전
     					2. 가장 먼저 올라간 박스로봇부터, 가능하면 한 칸 이동
     					3. 올라가는 위치에 로봇 없다면 하나 올린다
     					4. 내구도가 0인 칸의 개수가 K개 이상이라면 과정 종료. 그렇지 않으면 1번으로.
* `int ZeroCnt`  : 내구성이 `0`인 벨트의 개수

</br>

* `ZeroCnt < K`를 만족하는 동안 아래의 과정을 반복한다.

  1. 우선, `step++`로 한 단계 올려준다.

  2. `void rotateBelt(int[] Dura, ArrayList<Integer> box)` : 벨트를 한 칸씩 회전시켜주는 함수
     * 마지막 벨트 (`2N-1`번째)의 내구성 값을 저장해두고 `2N-2`번째 벨트부터 `0`번째 벨트까지 현 벨트의 내구성 값을 바로 다음 index의 `Dura`값으로 설정한다.
     * 만약, 현 벨트에 상자로봇이 있다면 다음 칸으로 위치를 바꿔준다.
       * 이때, 다음 칸이 내리는 위치(`N-1`)라면 그 상자로봇은 없앤다
     * 저장해둔 마지막벨트의 내구성 값을 `Dura[0]`으로 설정해주고, 박스가 있다면 위치를 바꿔준다.
  3. `int moveRobot(int[] Dura, ArrayList<Integer> box, int ZeroCnt)` : 로봇을 한 칸씩 이동
     * 이동하려는 칸의 index를 미리 저장해두고 처리한다
       * 마지막 벨트면 `0`으로, 아니면 `박스의 위치 + 1`으로
     * 이동하려는 칸에 로봇이 없고, 그 칸의 내구도가 `1`이상이라면 박스를 다음 칸으로 옮겨주고, 이동 후 그 자리의 내구성을 `-1`해준다. 
       * 이동한 자리의 내구성이 `0`이 되었다면 `ZeroCnt++`
       * 이동한 자리가 내려가는 자리라면 로봇 내려줌 -> 로봇 없앤다
         * **로봇 없애고 `for`문 index 바로 잡아주기!** 
  4. 올라가는 위치(`0`번째)에 로봇이 없다면 하나 올려준다
     * **이 때 올려줄 때에도 그 자리의 내구성이 `1`이상인지 확인해줘여한다!**
     * 로봇 올릴 수 있다면, 올린 후 그 위치의 내구성을 `-1`해주고, 만약 `0`이 되었다면 `ZeroCnt++` 을 해준다

</br>

## :speaking_head:

* 리스트 사용할 때, 삭제하면 index 확인하고 잘 맞춰주기
* 문제에 나와있는 조건 잘 확인하고 적용할 수 있는 부분에 다 적용해서 풀자 !