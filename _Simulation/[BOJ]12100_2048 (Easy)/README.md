# [BOJ]/[12100] 2048 (Easy)

## *- simulation -* 

**전역 변수**

```java
int Max = 0; // 5번 움직여서 만들 수 있는 수의 최대값
```

## solution

* 재귀 이용 - `void solution(int N, int[][] map, int cnt)`

  * 5번 중 매 회전마다 4방향 모두 이동시켜본다.

  * `int cnt` : 이동 횟수

    `0`이라면 5회 이동시킨 것으로 그 때의 가장 큰 수를 찾아 `Max`값을 갱신한다.

* 각 방향 이동은 각각의 메소드로 구현 (상, 하, 좌, 우)

예) 위로 이동 - `void MoveUp(int[][] map, int N)`

* 세로로 이동시키는 것으로 각 열마다 확인한다.

* 0번째 행부터 `N-1`번째 행까지

  1. 만약 현재 위치에 숫자가 없다면, (`0`이라면) 그 다음에 있는 숫자를 현재 위치로 옮긴다.

     * `0`이 아닌 값이 있을 때까지 인덱스를 늘려주며 찾는다.

       => 이 때, 그 인덱스값이 범위를 벗어난다면 다음 숫자가 없는 것으로 현재 행은 종료하고 다음 행을 확인.

  2. 현재 위치에 숫자가 있는 상태로, 그 다음에 있는 숫자를 찾는다.

     * `0`이 아닌 값이 있을 때까지 인덱스를 늘려주며 찾는다.

       => 이 때, 그 인덱스 값이 범위를 벗어난다면 다음 숫자가 없는 것으로 현재 행은 종료하고 다음 행을 확인.

     * 다음 숫자를 찾았다면, 현재 숫자와 비교한다.

       => 만약 두 숫자가 같다면, 현재 위치의 숫자를 `*2`해주고, 찾은 숫자는 없애준다. (현재 위치로 합쳐진 것)

## :speaking_head:

Easy!

